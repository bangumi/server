// SPDX-License-Identifier: AGPL-3.0-only
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published
// by the Free Software Foundation, version 3.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
// See the GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program. If not, see <https://www.gnu.org/licenses/>

//nolint:forbidigo
package main

import (
	_ "embed"
	"fmt"
	"os"
	"os/exec"
	"strings"

	"github.com/valyala/bytebufferpool"

	"github.com/bangumi/server/internal/strutil"
)

//go:embed template/template.go
var tpl string

const generatedHeader = "// Code generated by ./internal/cmd/gen/null/main.go. DO NOT EDIT.\n\n"

const fileAllTypes = `package null
func AllTypes() []interface{}{
	return []interface{}{
		%s
	}
}
`

func main() {
	var types = []string{
		"bool", "string", "uint8", "uint16", "uint32", "uint64", "int8", "int16", "int32", "int64",
	}

	for _, s := range types {
		var code = tpl
		code = strings.ReplaceAll(code, "convertToDriverValue(t.Type)", valueConverter(s))
		code = strings.ReplaceAll(code, "GenericType", s)
		code = strings.ReplaceAll(code, "Type", destType(s))

		outPath := fmt.Sprintf("./internal/pkg/null/%s.gen.go", s)
		err := os.WriteFile(outPath, []byte(generatedHeader+code), 0600) //nolint:gomnd
		if err != nil {
			panic(err)
		}

		Cmd("go", "fmt", outPath)
	}

	var a = strings.Join(strutil.Map(types, func(_ int, s string) string {
		return destType(s) + "{},"
	}), " ")

	outPath := "./internal/pkg/null/types.gen.go"
	err := os.WriteFile(outPath, []byte(generatedHeader+fmt.Sprintf(fileAllTypes, a)), 0600) //nolint:gomnd
	if err != nil {
		panic(err)
	}

	Cmd("go", "fmt", outPath)
}

func Cmd(name string, arg ...string) {
	stdout := bytebufferpool.Get()
	defer bytebufferpool.Put(stdout)
	stderr := bytebufferpool.Get()
	defer bytebufferpool.Put(stderr)

	cmd := exec.Command(name, arg...)
	cmd.Stdout = stdout
	cmd.Stderr = stderr

	if err := cmd.Run(); err != nil {
		fmt.Println(stdout.String())
		fmt.Println(stderr.String())

		panic(err)
	}
}

func valueConverter(t string) string {
	switch t {
	case "uint8", "uint16", "uint32", "uint64", "int8", "int16", "int32", "int64":
		return "int64(t.Type)"
	case "bool", "string":
		return "t.Type"
	}

	return "tt.Type"
}

func destType(s string) string {
	return strings.ToUpper(s[:1]) + strings.ToLower(s[1:])
}

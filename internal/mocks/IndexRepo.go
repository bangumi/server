// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package mocks

import (
	"context"

	"github.com/bangumi/server/internal/index"
	"github.com/bangumi/server/internal/model"
	mock "github.com/stretchr/testify/mock"
)

// NewIndexRepo creates a new instance of IndexRepo. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIndexRepo(t interface {
	mock.TestingT
	Cleanup(func())
}) *IndexRepo {
	mock := &IndexRepo{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// IndexRepo is an autogenerated mock type for the Repo type
type IndexRepo struct {
	mock.Mock
}

type IndexRepo_Expecter struct {
	mock *mock.Mock
}

func (_m *IndexRepo) EXPECT() *IndexRepo_Expecter {
	return &IndexRepo_Expecter{mock: &_m.Mock}
}

// AddIndexCollect provides a mock function for the type IndexRepo
func (_mock *IndexRepo) AddIndexCollect(ctx context.Context, id model.IndexID, uid model.UserID) error {
	ret := _mock.Called(ctx, id, uid)

	if len(ret) == 0 {
		panic("no return value specified for AddIndexCollect")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, model.IndexID, model.UserID) error); ok {
		r0 = returnFunc(ctx, id, uid)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// IndexRepo_AddIndexCollect_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddIndexCollect'
type IndexRepo_AddIndexCollect_Call struct {
	*mock.Call
}

// AddIndexCollect is a helper method to define mock.On call
//   - ctx
//   - id
//   - uid
func (_e *IndexRepo_Expecter) AddIndexCollect(ctx interface{}, id interface{}, uid interface{}) *IndexRepo_AddIndexCollect_Call {
	return &IndexRepo_AddIndexCollect_Call{Call: _e.mock.On("AddIndexCollect", ctx, id, uid)}
}

func (_c *IndexRepo_AddIndexCollect_Call) Run(run func(ctx context.Context, id model.IndexID, uid model.UserID)) *IndexRepo_AddIndexCollect_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(model.IndexID), args[2].(model.UserID))
	})
	return _c
}

func (_c *IndexRepo_AddIndexCollect_Call) Return(err error) *IndexRepo_AddIndexCollect_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *IndexRepo_AddIndexCollect_Call) RunAndReturn(run func(ctx context.Context, id model.IndexID, uid model.UserID) error) *IndexRepo_AddIndexCollect_Call {
	_c.Call.Return(run)
	return _c
}

// AddOrUpdateIndexSubject provides a mock function for the type IndexRepo
func (_mock *IndexRepo) AddOrUpdateIndexSubject(ctx context.Context, id model.IndexID, subjectID model.SubjectID, sort uint32, comment string) (*index.Subject, error) {
	ret := _mock.Called(ctx, id, subjectID, sort, comment)

	if len(ret) == 0 {
		panic("no return value specified for AddOrUpdateIndexSubject")
	}

	var r0 *index.Subject
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, model.IndexID, model.SubjectID, uint32, string) (*index.Subject, error)); ok {
		return returnFunc(ctx, id, subjectID, sort, comment)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, model.IndexID, model.SubjectID, uint32, string) *index.Subject); ok {
		r0 = returnFunc(ctx, id, subjectID, sort, comment)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*index.Subject)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, model.IndexID, model.SubjectID, uint32, string) error); ok {
		r1 = returnFunc(ctx, id, subjectID, sort, comment)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// IndexRepo_AddOrUpdateIndexSubject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddOrUpdateIndexSubject'
type IndexRepo_AddOrUpdateIndexSubject_Call struct {
	*mock.Call
}

// AddOrUpdateIndexSubject is a helper method to define mock.On call
//   - ctx
//   - id
//   - subjectID
//   - sort
//   - comment
func (_e *IndexRepo_Expecter) AddOrUpdateIndexSubject(ctx interface{}, id interface{}, subjectID interface{}, sort interface{}, comment interface{}) *IndexRepo_AddOrUpdateIndexSubject_Call {
	return &IndexRepo_AddOrUpdateIndexSubject_Call{Call: _e.mock.On("AddOrUpdateIndexSubject", ctx, id, subjectID, sort, comment)}
}

func (_c *IndexRepo_AddOrUpdateIndexSubject_Call) Run(run func(ctx context.Context, id model.IndexID, subjectID model.SubjectID, sort uint32, comment string)) *IndexRepo_AddOrUpdateIndexSubject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(model.IndexID), args[2].(model.SubjectID), args[3].(uint32), args[4].(string))
	})
	return _c
}

func (_c *IndexRepo_AddOrUpdateIndexSubject_Call) Return(subject *index.Subject, err error) *IndexRepo_AddOrUpdateIndexSubject_Call {
	_c.Call.Return(subject, err)
	return _c
}

func (_c *IndexRepo_AddOrUpdateIndexSubject_Call) RunAndReturn(run func(ctx context.Context, id model.IndexID, subjectID model.SubjectID, sort uint32, comment string) (*index.Subject, error)) *IndexRepo_AddOrUpdateIndexSubject_Call {
	_c.Call.Return(run)
	return _c
}

// CountSubjects provides a mock function for the type IndexRepo
func (_mock *IndexRepo) CountSubjects(ctx context.Context, id model.IndexID, subjectType model.SubjectType) (int64, error) {
	ret := _mock.Called(ctx, id, subjectType)

	if len(ret) == 0 {
		panic("no return value specified for CountSubjects")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, model.IndexID, model.SubjectType) (int64, error)); ok {
		return returnFunc(ctx, id, subjectType)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, model.IndexID, model.SubjectType) int64); ok {
		r0 = returnFunc(ctx, id, subjectType)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, model.IndexID, model.SubjectType) error); ok {
		r1 = returnFunc(ctx, id, subjectType)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// IndexRepo_CountSubjects_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CountSubjects'
type IndexRepo_CountSubjects_Call struct {
	*mock.Call
}

// CountSubjects is a helper method to define mock.On call
//   - ctx
//   - id
//   - subjectType
func (_e *IndexRepo_Expecter) CountSubjects(ctx interface{}, id interface{}, subjectType interface{}) *IndexRepo_CountSubjects_Call {
	return &IndexRepo_CountSubjects_Call{Call: _e.mock.On("CountSubjects", ctx, id, subjectType)}
}

func (_c *IndexRepo_CountSubjects_Call) Run(run func(ctx context.Context, id model.IndexID, subjectType model.SubjectType)) *IndexRepo_CountSubjects_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(model.IndexID), args[2].(model.SubjectType))
	})
	return _c
}

func (_c *IndexRepo_CountSubjects_Call) Return(n int64, err error) *IndexRepo_CountSubjects_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *IndexRepo_CountSubjects_Call) RunAndReturn(run func(ctx context.Context, id model.IndexID, subjectType model.SubjectType) (int64, error)) *IndexRepo_CountSubjects_Call {
	_c.Call.Return(run)
	return _c
}

// Delete provides a mock function for the type IndexRepo
func (_mock *IndexRepo) Delete(ctx context.Context, id model.IndexID) error {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, model.IndexID) error); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// IndexRepo_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type IndexRepo_Delete_Call struct {
	*mock.Call
}

// Delete is a helper method to define mock.On call
//   - ctx
//   - id
func (_e *IndexRepo_Expecter) Delete(ctx interface{}, id interface{}) *IndexRepo_Delete_Call {
	return &IndexRepo_Delete_Call{Call: _e.mock.On("Delete", ctx, id)}
}

func (_c *IndexRepo_Delete_Call) Run(run func(ctx context.Context, id model.IndexID)) *IndexRepo_Delete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(model.IndexID))
	})
	return _c
}

func (_c *IndexRepo_Delete_Call) Return(err error) *IndexRepo_Delete_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *IndexRepo_Delete_Call) RunAndReturn(run func(ctx context.Context, id model.IndexID) error) *IndexRepo_Delete_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteIndexCollect provides a mock function for the type IndexRepo
func (_mock *IndexRepo) DeleteIndexCollect(ctx context.Context, id model.IndexID, uid model.UserID) error {
	ret := _mock.Called(ctx, id, uid)

	if len(ret) == 0 {
		panic("no return value specified for DeleteIndexCollect")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, model.IndexID, model.UserID) error); ok {
		r0 = returnFunc(ctx, id, uid)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// IndexRepo_DeleteIndexCollect_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteIndexCollect'
type IndexRepo_DeleteIndexCollect_Call struct {
	*mock.Call
}

// DeleteIndexCollect is a helper method to define mock.On call
//   - ctx
//   - id
//   - uid
func (_e *IndexRepo_Expecter) DeleteIndexCollect(ctx interface{}, id interface{}, uid interface{}) *IndexRepo_DeleteIndexCollect_Call {
	return &IndexRepo_DeleteIndexCollect_Call{Call: _e.mock.On("DeleteIndexCollect", ctx, id, uid)}
}

func (_c *IndexRepo_DeleteIndexCollect_Call) Run(run func(ctx context.Context, id model.IndexID, uid model.UserID)) *IndexRepo_DeleteIndexCollect_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(model.IndexID), args[2].(model.UserID))
	})
	return _c
}

func (_c *IndexRepo_DeleteIndexCollect_Call) Return(err error) *IndexRepo_DeleteIndexCollect_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *IndexRepo_DeleteIndexCollect_Call) RunAndReturn(run func(ctx context.Context, id model.IndexID, uid model.UserID) error) *IndexRepo_DeleteIndexCollect_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteIndexSubject provides a mock function for the type IndexRepo
func (_mock *IndexRepo) DeleteIndexSubject(ctx context.Context, id model.IndexID, subjectID model.SubjectID) error {
	ret := _mock.Called(ctx, id, subjectID)

	if len(ret) == 0 {
		panic("no return value specified for DeleteIndexSubject")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, model.IndexID, model.SubjectID) error); ok {
		r0 = returnFunc(ctx, id, subjectID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// IndexRepo_DeleteIndexSubject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteIndexSubject'
type IndexRepo_DeleteIndexSubject_Call struct {
	*mock.Call
}

// DeleteIndexSubject is a helper method to define mock.On call
//   - ctx
//   - id
//   - subjectID
func (_e *IndexRepo_Expecter) DeleteIndexSubject(ctx interface{}, id interface{}, subjectID interface{}) *IndexRepo_DeleteIndexSubject_Call {
	return &IndexRepo_DeleteIndexSubject_Call{Call: _e.mock.On("DeleteIndexSubject", ctx, id, subjectID)}
}

func (_c *IndexRepo_DeleteIndexSubject_Call) Run(run func(ctx context.Context, id model.IndexID, subjectID model.SubjectID)) *IndexRepo_DeleteIndexSubject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(model.IndexID), args[2].(model.SubjectID))
	})
	return _c
}

func (_c *IndexRepo_DeleteIndexSubject_Call) Return(err error) *IndexRepo_DeleteIndexSubject_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *IndexRepo_DeleteIndexSubject_Call) RunAndReturn(run func(ctx context.Context, id model.IndexID, subjectID model.SubjectID) error) *IndexRepo_DeleteIndexSubject_Call {
	_c.Call.Return(run)
	return _c
}

// Get provides a mock function for the type IndexRepo
func (_mock *IndexRepo) Get(ctx context.Context, id model.IndexID) (model.Index, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 model.Index
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, model.IndexID) (model.Index, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, model.IndexID) model.Index); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Get(0).(model.Index)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, model.IndexID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// IndexRepo_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type IndexRepo_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - ctx
//   - id
func (_e *IndexRepo_Expecter) Get(ctx interface{}, id interface{}) *IndexRepo_Get_Call {
	return &IndexRepo_Get_Call{Call: _e.mock.On("Get", ctx, id)}
}

func (_c *IndexRepo_Get_Call) Run(run func(ctx context.Context, id model.IndexID)) *IndexRepo_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(model.IndexID))
	})
	return _c
}

func (_c *IndexRepo_Get_Call) Return(index1 model.Index, err error) *IndexRepo_Get_Call {
	_c.Call.Return(index1, err)
	return _c
}

func (_c *IndexRepo_Get_Call) RunAndReturn(run func(ctx context.Context, id model.IndexID) (model.Index, error)) *IndexRepo_Get_Call {
	_c.Call.Return(run)
	return _c
}

// GetIndexCollect provides a mock function for the type IndexRepo
func (_mock *IndexRepo) GetIndexCollect(ctx context.Context, id model.IndexID, uid model.UserID) (*index.IndexCollect, error) {
	ret := _mock.Called(ctx, id, uid)

	if len(ret) == 0 {
		panic("no return value specified for GetIndexCollect")
	}

	var r0 *index.IndexCollect
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, model.IndexID, model.UserID) (*index.IndexCollect, error)); ok {
		return returnFunc(ctx, id, uid)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, model.IndexID, model.UserID) *index.IndexCollect); ok {
		r0 = returnFunc(ctx, id, uid)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*index.IndexCollect)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, model.IndexID, model.UserID) error); ok {
		r1 = returnFunc(ctx, id, uid)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// IndexRepo_GetIndexCollect_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetIndexCollect'
type IndexRepo_GetIndexCollect_Call struct {
	*mock.Call
}

// GetIndexCollect is a helper method to define mock.On call
//   - ctx
//   - id
//   - uid
func (_e *IndexRepo_Expecter) GetIndexCollect(ctx interface{}, id interface{}, uid interface{}) *IndexRepo_GetIndexCollect_Call {
	return &IndexRepo_GetIndexCollect_Call{Call: _e.mock.On("GetIndexCollect", ctx, id, uid)}
}

func (_c *IndexRepo_GetIndexCollect_Call) Run(run func(ctx context.Context, id model.IndexID, uid model.UserID)) *IndexRepo_GetIndexCollect_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(model.IndexID), args[2].(model.UserID))
	})
	return _c
}

func (_c *IndexRepo_GetIndexCollect_Call) Return(indexCollect *index.IndexCollect, err error) *IndexRepo_GetIndexCollect_Call {
	_c.Call.Return(indexCollect, err)
	return _c
}

func (_c *IndexRepo_GetIndexCollect_Call) RunAndReturn(run func(ctx context.Context, id model.IndexID, uid model.UserID) (*index.IndexCollect, error)) *IndexRepo_GetIndexCollect_Call {
	_c.Call.Return(run)
	return _c
}

// ListSubjects provides a mock function for the type IndexRepo
func (_mock *IndexRepo) ListSubjects(ctx context.Context, id model.IndexID, subjectType model.SubjectType, limit int, offset int) ([]index.Subject, error) {
	ret := _mock.Called(ctx, id, subjectType, limit, offset)

	if len(ret) == 0 {
		panic("no return value specified for ListSubjects")
	}

	var r0 []index.Subject
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, model.IndexID, model.SubjectType, int, int) ([]index.Subject, error)); ok {
		return returnFunc(ctx, id, subjectType, limit, offset)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, model.IndexID, model.SubjectType, int, int) []index.Subject); ok {
		r0 = returnFunc(ctx, id, subjectType, limit, offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]index.Subject)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, model.IndexID, model.SubjectType, int, int) error); ok {
		r1 = returnFunc(ctx, id, subjectType, limit, offset)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// IndexRepo_ListSubjects_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListSubjects'
type IndexRepo_ListSubjects_Call struct {
	*mock.Call
}

// ListSubjects is a helper method to define mock.On call
//   - ctx
//   - id
//   - subjectType
//   - limit
//   - offset
func (_e *IndexRepo_Expecter) ListSubjects(ctx interface{}, id interface{}, subjectType interface{}, limit interface{}, offset interface{}) *IndexRepo_ListSubjects_Call {
	return &IndexRepo_ListSubjects_Call{Call: _e.mock.On("ListSubjects", ctx, id, subjectType, limit, offset)}
}

func (_c *IndexRepo_ListSubjects_Call) Run(run func(ctx context.Context, id model.IndexID, subjectType model.SubjectType, limit int, offset int)) *IndexRepo_ListSubjects_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(model.IndexID), args[2].(model.SubjectType), args[3].(int), args[4].(int))
	})
	return _c
}

func (_c *IndexRepo_ListSubjects_Call) Return(subjects []index.Subject, err error) *IndexRepo_ListSubjects_Call {
	_c.Call.Return(subjects, err)
	return _c
}

func (_c *IndexRepo_ListSubjects_Call) RunAndReturn(run func(ctx context.Context, id model.IndexID, subjectType model.SubjectType, limit int, offset int) ([]index.Subject, error)) *IndexRepo_ListSubjects_Call {
	_c.Call.Return(run)
	return _c
}

// New provides a mock function for the type IndexRepo
func (_mock *IndexRepo) New(ctx context.Context, i *model.Index) error {
	ret := _mock.Called(ctx, i)

	if len(ret) == 0 {
		panic("no return value specified for New")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *model.Index) error); ok {
		r0 = returnFunc(ctx, i)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// IndexRepo_New_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'New'
type IndexRepo_New_Call struct {
	*mock.Call
}

// New is a helper method to define mock.On call
//   - ctx
//   - i
func (_e *IndexRepo_Expecter) New(ctx interface{}, i interface{}) *IndexRepo_New_Call {
	return &IndexRepo_New_Call{Call: _e.mock.On("New", ctx, i)}
}

func (_c *IndexRepo_New_Call) Run(run func(ctx context.Context, i *model.Index)) *IndexRepo_New_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*model.Index))
	})
	return _c
}

func (_c *IndexRepo_New_Call) Return(err error) *IndexRepo_New_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *IndexRepo_New_Call) RunAndReturn(run func(ctx context.Context, i *model.Index) error) *IndexRepo_New_Call {
	_c.Call.Return(run)
	return _c
}

// Update provides a mock function for the type IndexRepo
func (_mock *IndexRepo) Update(ctx context.Context, id model.IndexID, title string, desc string) error {
	ret := _mock.Called(ctx, id, title, desc)

	if len(ret) == 0 {
		panic("no return value specified for Update")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, model.IndexID, string, string) error); ok {
		r0 = returnFunc(ctx, id, title, desc)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// IndexRepo_Update_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Update'
type IndexRepo_Update_Call struct {
	*mock.Call
}

// Update is a helper method to define mock.On call
//   - ctx
//   - id
//   - title
//   - desc
func (_e *IndexRepo_Expecter) Update(ctx interface{}, id interface{}, title interface{}, desc interface{}) *IndexRepo_Update_Call {
	return &IndexRepo_Update_Call{Call: _e.mock.On("Update", ctx, id, title, desc)}
}

func (_c *IndexRepo_Update_Call) Run(run func(ctx context.Context, id model.IndexID, title string, desc string)) *IndexRepo_Update_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(model.IndexID), args[2].(string), args[3].(string))
	})
	return _c
}

func (_c *IndexRepo_Update_Call) Return(err error) *IndexRepo_Update_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *IndexRepo_Update_Call) RunAndReturn(run func(ctx context.Context, id model.IndexID, title string, desc string) error) *IndexRepo_Update_Call {
	_c.Call.Return(run)
	return _c
}
